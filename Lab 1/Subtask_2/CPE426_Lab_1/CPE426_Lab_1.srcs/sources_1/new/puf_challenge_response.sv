`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 10/22/2023 02:05:28 PM
// Design Name: 
// Module Name: puf_challenge_response
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////

// -----------------------------------------------------------------------------
// Module: puf_challenge_response
//
// Description:
// This module implements a Finite State Machine (FSM) to interact with a 
// Physically Unclonable Function (PUF). It takes a 6-bit challenge as input 
// and produces an 8-bit response based on the PUF's behavior. The FSM goes 
// through several states including IDLE, START, WAIT, STORE, INCREMENT, and 
// COMPARE to manage the PUF operation and generate the response.
//
// Ports:
// - CLK: Clock input
// - challenge_lower_bits: Lower 6 bits of the challenge
// - response: 8-bit response generated by the FSM
// -----------------------------------------------------------------------------
`define TRUE    1'b1
`define FALSE   1'b0
`define num_RO  8

module puf_challenge_response(
    input logic CLK,                    // Clock input
    input [5:0] challenge_lower_bits,   // Lower 6 bits of the challenge
    output logic [7:0] response         // Response bits
);

    // Define FSM states
    typedef enum logic [3:0] {
        IDLE = 4'b0000,
        START,
        WAIT,
        STORE,
        INCREMENT,
        COMPARE
    } fsm_state_t;
    fsm_state_t state = IDLE, next_state;  // Initialize current and next FSM states
    
    logic [31:0] ro_count_out = 0;  // Initialize 32-bit counter output from PUF
    logic [9:0] challenge = 0;      // Initialize 10-bit challenge input to PUF
    logic count_complete = 0;       // Initialize signal indicating PUF operation complete
    logic comparison_done = 0;      // Initialize flag for comparison completion
    logic [31:0] ro_count_array [8:0];  // 2D Array to store ro_count_out values
    logic [3:0] index = 4'b0000;    // Initialize index for array and upper 4 bits of challenge

    // FSM state transition logic
    always_ff @(posedge CLK) begin
        state <= next_state;
    end

    // Next state logic based on current state and other conditions
    always_comb begin
        next_state = state;
        case(state)
                 IDLE:                      next_state = START;
                START:                      next_state = WAIT;
                 WAIT: if (count_complete)  next_state = STORE;
                STORE:                      next_state = INCREMENT;
            INCREMENT: if (index <= `num_RO)next_state = START;
                       else                 next_state = COMPARE;
              COMPARE: if (comparison_done) next_state = IDLE;
              default:                      next_state = IDLE;
        endcase
    end

    // START state: Update challenge bits
    always_comb begin
        if (state == START) challenge = {index, challenge_lower_bits};
    end
    
    // Sequential Logic
    always_ff @(posedge CLK) begin
        // IDLE state: reset challenge bit and comparison flag
        if (state == IDLE) begin
            index <= 4'b0000; //Reset upper challenges
            comparison_done <= `FALSE; // Reset the flag at the beginning of each cycle
        end
        
        //STORE state: Logic to store ro_count_out into array
        if (state == STORE) ro_count_array[index] <= ro_count_out;
        
        // INCREMENT state: Increment index used for challenge bit
        if (state == INCREMENT) index <= index + 1;
        
        // COMPARE state: compare the counters and generate resposne        
        if (state == COMPARE) begin            
            for (int i = 0; i < `num_RO; i = i + 1) begin
                response[i] <= (ro_count_array[i] > ro_count_array[i+1]) ? `TRUE : `FALSE;
            end            
            comparison_done <= `TRUE; // Set the comparison_done flag
        end       

    end

    // Instantiate configurable_RO_PUF
    logic enable_ro_puf;  // Declare a new logic variable for the enable signal
    assign enable_ro_puf = (state !== START) && (state !== IDLE) && (state !== COMPARE);
    configurable_RO_PUF puf_inst (
        .challenge(challenge),
        .clk(CLK),
        .en(enable_ro_puf),
        .ro_count_out(ro_count_out),
        .completed(count_complete)
    );
endmodule
